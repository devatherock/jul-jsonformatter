package io.github.devatherock.json.formatter.testhelpers;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintStream;
import java.util.Map;
import java.util.concurrent.ExecutionException;
import java.util.logging.Level;
import java.util.logging.LogManager;
import java.util.logging.Logger;
import java.util.regex.Pattern;

import io.github.devatherock.json.formatter.helpers.Constants;
import io.github.devatherock.json.formatter.helpers.Constants.ExceptionKeys;

/**
 * Helper class for testing log formatting
 * 
 * @author Devaprasadh Xavier
 *
 */
public class TestUtil {
    public static final Pattern TIMESTAMP_PATTERN = Pattern.compile(
            "[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2}.[0-9]{3}([Z]{1}|[-+]{1}[0-9]{2}:[0-5]{1}[0-9]{1})");

    /**
     * Loads config from a file named {@code logging.properties} in class path
     */
    public static void loadLoggingConfig() {
        loadLoggingConfig("logging.properties");
    }

    /**
     * Loads the specified config file from class path
     *
     * @param configFile
     */
    public static void loadLoggingConfig(String configFile) {
        try (InputStream inputStream = TestUtil.class.getClassLoader().getResourceAsStream(configFile);) {
            LogManager.getLogManager().readConfiguration(inputStream);
        } catch (IOException e) {
            Logger.getAnonymousLogger().severe(String.format("Could not load %s file", configFile));
            Logger.getAnonymousLogger().severe(e.getMessage());
        }
    }

    /**
     * Verifies the JSON generated by a simple log line without exception stack
     * traces
     * 
     * @param jsonMap
     * @param loggerName
     * @param message
     * @param logLevel
     */
    public static void verifyJson(Map<String, Object> jsonMap, String loggerName, String message, String logLevel) {
        assertNotNull(jsonMap.get(Constants.KEY_TIMESTAMP));
        assertTrue(TestUtil.TIMESTAMP_PATTERN.matcher(jsonMap.get(Constants.KEY_TIMESTAMP).toString()).matches());
        assertEquals(loggerName, jsonMap.get(Constants.KEY_LOGGER_NAME));
        assertEquals(logLevel, jsonMap.get(Constants.KEY_LOG_LEVEL));
        assertNotNull(jsonMap.get(Constants.KEY_THREAD_NAME));
        assertEquals(message, jsonMap.get(Constants.KEY_MESSAGE));
    }

    /**
     * Captures console output into a stream
     * 
     * @return {@code ByteArrayOutputStream}
     */
    public static ByteArrayOutputStream captureConsole() {
        final ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
        System.setErr(new PrintStream(outputStream));

        return outputStream;
    }

    /**
     * Verifies the logged exception object for an exception without message
     * 
     * @param exception
     * @param jsonMap
     */
    public static void verifyExceptionWithoutMessage(Exception exception, Map<String, Object> jsonMap) {
        assertNotNull(jsonMap.get(Constants.KEY_EXCEPTION));
        Map<String, Object> exceptionMap = (Map<String, Object>) jsonMap.get(Constants.KEY_EXCEPTION);
        assertEquals(exception.getClass().getName(), exceptionMap.get(ExceptionKeys.exception_class.name()));
        assertFalse(exceptionMap.containsKey(ExceptionKeys.exception_message.name()));
        assertTrue(exceptionMap.containsKey(ExceptionKeys.stack_trace.name()));
        assertTrue(exceptionMap.get(ExceptionKeys.stack_trace.name()) instanceof String);
    }

    /**
     * Verifies the logged exception object for an exception with message
     * 
     * @param exception
     * @param jsonMap
     */
    public static void verifyExceptionWithMessage(Exception exception, Map<String, Object> jsonMap) {
        verifyExceptionWithMessage(Constants.KEY_EXCEPTION, exception, jsonMap);
    }

    /**
     * Verifies the logged exception object for an exception with message
     *
     * @param exceptionKey
     * @param exception
     * @param jsonMap
     */
    public static void verifyExceptionWithMessage(String exceptionKey, Exception exception,
                                                  Map<String, Object> jsonMap) {
        assertNotNull(jsonMap.get(exceptionKey));
        Map<String, Object> exceptionMap = (Map<String, Object>) jsonMap.get(exceptionKey);
        assertEquals(exception.getClass().getName(), exceptionMap.get(ExceptionKeys.exception_class.name()));
        assertEquals(exception.getMessage(), exceptionMap.get(ExceptionKeys.exception_message.name()));
        assertTrue(exceptionMap.containsKey(ExceptionKeys.stack_trace.name()));
        assertTrue(exceptionMap.get(ExceptionKeys.stack_trace.name()) instanceof String);
    }

    /**
     * Logs a set of messages using the logger that is provided as input
     * 
     * @param logger
     * @throws InterruptedException
     * @throws ExecutionException
     */
    public static void logMessages(Logger logger) throws InterruptedException, ExecutionException {
        // Message with exception object with exception message
        logger.log(Level.SEVERE, "Test message with exception", new RuntimeException("test exception"));
    }
}
